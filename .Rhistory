getwd()
create_package("D:/seasonality/seasonal-spline/sGPfit")
library(availiable)
library(roxygen2)
create_package("D:/seasonality/seasonal-spline/sGPfit")
load_all()
library(devtools)
load_all()
create_package("D:/seasonality/seasonal-spline/sGPfit")
library(devtools)
create_package("D:/seasonality/sGPfit")
library(devtools)
library(sGPfit)
Matrix::as()
?Matrix::as()
rmvnp
mvrnorm
mvtnorm::mvrnorm
?as
document()
document()
document()
document()
document()
library(sGPfit)
library(sGPfit)
document()
?sGPfit::library.dynam.unload()
?gaussian
?gaussprocess
library(sGPfit)
sG
gaussprocess(from = 0, to = 1, K = function(s, t) {min(s, t)}, start = 0, m = 1000)
gaussprocess(from = 0, to = 1, K = function(s, t) {min(s, t)}, start = 0, m = 100)
library(sGPfit)
gaussprocess(from = 0, to = 1, K = function(s, t) {min(s, t)}, start = 0, m = 10)
generate_K_true(1,1)
fun <- generate_K_true(1,1)
fun(1,2)
compute_matrix_given_cov(from = 0, to = 1, m = 10, K = fun)
joint_prec_construct(t_vec = c(1,2,3), a = 1, sd = 1)
Compute_Q_Bt(a = 1, k = 3, region = c(0,1))
Compute_Q_Bt(a = 1, k = 5, region = c(0,1))
?Matrix::t()
Matrix::t()
Matrix::t(s)
Matrix::t(1)
Matrix::as()
Matrix::as(1)
library(sGPfit)
Compute_Q_Bt(a = 1, k = 5, region = c(0,1))
library(sGPfit)
Compute_Q_Bt(a = 1, k = 5, region = c(0,1))
library(sGPfit)
Compute_Q_Bt(a = 1, k = 5, region = c(0,1))
library(sGPfit)
Compute_Q_Bt(a = 1, k = 5, region = c(0,1))
Compute_Q_Bt(a = 1, k = 5, region = c(0,1))
Bcos
t(Bcos)
Matrix::t(Bcos)
library(Matrix)
t(Bcos)
Bcos
B2cos
t(Bcos)
t(Bcos)
?t()
Matrix::t(Bcos)
UseMethod(t)
UseMethod("t")
library(sGPfit)
documents()
library(devtools)
document()
document()
document()
library(sGPfit)
Compute_Q_Bt(a = 1, k = 5, region = c(0,1))
Compute_B_Bt(x = c(1,2,3), a = 1, k = 5, region = c(0,1))
Compute_B_Bt(x = c(1,2,3), a = 1, k = 5, region = c(0,3))
sampling_from_weights(x = c(1,2,3), a = 1, k = 5, region = c(0,5))
document()
library(sGPfit)
document()
usethis::use_testthat(3)
usethis::use_testthat()
library(sGPfit)
?sGPfit::Compute_Q_Bt()
Q <- Compute_Q_Bt(a = 1, k = 5, region = c(0,1))
?Compute_B_Bt
Compute_Q_Bt
B <- Compute_B_Bt(x = c(0.1,0.5,0.8), a = 1, k = 5, region = c(0,1))
B
expect_equal(dim(Q), c(8,8))
library(testthat)
expect_equal(dim(Q), c(8,8))
Q
Compute_Q_Bt
expect_equal(dim(Q), c(6,6))
expect_equal(dim(Compute_Q_Bt(a = 1, k = 5, region = c(0,1), boundary = T)), c(10,10))
expect_equal(dim(Compute_Q_Bt(a = 1, k = 5, region = c(0,1), boundary = FALSE)), c(10,10))
dim(Compute_Q_Bt(a = 1, k = 5, region = c(0,1), boundary = FALSE))
Compute_Q_Bt(a = 1, k = 5, region = c(0,1), boundary = FALSE)
expect_equal(dim(B), c(3,6))
dim(B)
test_that("Dimensions of created matrices are correct",{
expect_equal(dim(Q), c(6,6))
expect_equal(dim(Compute_Q_Bt(a = 1, k = 5, region = c(0,1), boundary = FALSE)), c(10,10))
expect_equal(dim(B), c(3,6))
expect_equal(dim(Compute_B_Bt(x = c(0.1,0.5,0.8), a = 1, k = 5, region = c(0,1), boundary = FALSE)), c(3,10))
}
)
## Construct precision matrix:
Q <- Compute_Q_Bt(a = 1, k = 5, region = c(0,1))
Q2 <- Compute_Q_Bt(a = 1, k = 5, region = c(0,1), boundary = FALSE)
## Construct design matrix:
B <- Compute_B_Bt(x = c(0.1,0.5,0.8), a = 1, k = 5, region = c(0,1))
B2 <- Compute_B_Bt(x = c(0.1,0.5,0.8), a = 1, k = 5, region = c(0,1), boundary = FALSE)
test_that("Dimensions of created matrices are correct",{
expect_equal(dim(Q), c(6,6))
expect_equal(dim(Q2), c(10,10))
expect_equal(dim(B), c(3,6))
expect_equal(dim(B2), c(3,10))
}
)
type(Q)
class(Q)
test_that("Classes of created matrices are correct",{
expect_equal(class(Q), "dsCMatrix")
expect_equal(class(Q2), "dsCMatrix")
expect_equal(class(B), "dsCMatrix")
expect_equal(class(B2), "dsCMatrix")
}
)
class(Q)
class(Q)[[1]]
test_that("Classes of created matrices are correct",{
expect_equal(class(Q)[[1]], "dsCMatrix")
expect_equal(class(Q2)[[1]], "dsCMatrix")
expect_equal(class(B)[[1]], "dsCMatrix")
expect_equal(class(B2)[[1]], "dsCMatrix")
}
)
class(B)
class(B)[[1]]
test_that("Classes of created matrices are correct",{
expect_equal(class(Q)[[1]], "dsCMatrix")
expect_equal(class(Q2)[[1]], "dsCMatrix")
expect_equal(class(B)[[1]], "matrix")
expect_equal(class(B2)[[1]], "matrix")
}
)
eigen(Q, only.values = T)
eigen(Q, only.values = T)
expect_equal(min(eigen(Q, only.values = T)$values)>=0, TRUE)
min(eigen(Q2, only.values = T)$values)
test_that("Precision matrices have correct eigenvalues",{
expect_equal(min(eigen(Q, only.values = T)$values)>=0, TRUE)
expect_equal(min(eigen(Q2, only.values = T)$values), 0, tolerance = 0.0001)
}
)
Q <- Compute_Q_Bt(a = 1, k = 10, region = c(0,10), boundary = TRUE)
min(eigen(Q, only.values = T)$values)
Q <- Compute_Q_Bt(a = 1, k = 5, region = c(0,10), boundary = TRUE)
min(eigen(Q, only.values = T)$values)
## Construct precision matrix:
Q <- Compute_Q_Bt(a = 1, k = 5, region = c(0,10), boundary = TRUE)
Q2 <- Compute_Q_Bt(a = 1, k = 5, region = c(0,1), boundary = FALSE)
## Construct design matrix:
B <- Compute_B_Bt(x = c(0.1,0.5,0.8), a = 1, k = 5, region = c(0,1))
B2 <- Compute_B_Bt(x = c(0.1,0.5,0.8), a = 1, k = 5, region = c(0,1), boundary = FALSE)
test_that("Dimensions of created matrices are correct",{
expect_equal(dim(Q), c(6,6))
expect_equal(dim(Q2), c(10,10))
expect_equal(dim(B), c(3,6))
expect_equal(dim(B2), c(3,10))
}
)
test_that("Classes of created matrices are correct",{
expect_equal(class(Q)[[1]], "dsCMatrix")
expect_equal(class(Q2)[[1]], "dsCMatrix")
expect_equal(class(B)[[1]], "matrix")
expect_equal(class(B2)[[1]], "matrix")
}
)
test_that("Precision matrices have correct eigenvalues",{
expect_equal(min(eigen(Q, only.values = T)$values)>=0, TRUE)
expect_equal(min(eigen(Q2, only.values = T)$values), 0, tolerance = 0.0001)
}
)
Q <- joint_prec_construct(t_vec = c(0.1,0.2,0.3), a = 1, sd = 1)
expect_equal(dim(Q), c(6,6))
test_that("Dimensions of created matrices are correct",{
expect_equal(dim(Q), c(6,6))
}
)
test_that("Precision matrices have correct eigenvalues",{
expect_equal(min(eigen(Q, only.values = T)$values)>=0, TRUE)
}
)
min(eigen(Q, only.values = T)$values)
expect_equal(min(eigen(Q[c(1,3,5), c(1,3,5)], only.values = T)$values)>=0, TRUE)
test_that("Precision matrices have correct eigenvalues",{
expect_equal(min(eigen(Q, only.values = T)$values)>=0, TRUE)
expect_equal(min(eigen(Q[c(1,3,5), c(1,3,5)], only.values = T)$values)>=0, TRUE)
expect_equal(min(eigen(Q[c(2,4,6), c(2,4,6)], only.values = T)$values)>=0, TRUE)
}
)
Exact <- compute_matrix_given_cov(from = 0.1, to = 0.3, m = 3, K = generate_K_true(1,1))
Exact
solve(Q[c(1,3,5), c(1,3,5)])
compute_matrix_given_cov
solve(Q)[c(1,3,5), c(1,3,5)]
Exact
max(solve(Q)[c(1,3,5), c(1,3,5)] - Exact)
test_that("Covariance matrices match the exact one",{
expect_equal(max(solve(Q)[c(1,3,5), c(1,3,5)] - Exact), 0, tolerance = 0.001)
}
)
library(sGPfit)
library(devtools)
usethis::use_vignette("sGPfit")
browseVignettes("SPCompute")
vignette(package = "SPCompute")
browseVignettes()
library(tidyverse)
library(sGPfit)
?compute_matrix_given_cov
locations <- seq(0.1,1, by = 0.1)
K_true <- generate_K_true(sigma = 1, alpha = 1)
C_True <- compute_matrix_given_cov(from = 0.1, to = 1, m = 10, K = K_true)
samps <- gaussprocess(from = 0.1, to = 1, m = 10, K = K_true)
samps
samps <- gaussprocess(from = 0.1, to = 1, m = 10, K = K_true, m = 10)
samps <- gaussprocess(from = 0.1, to = 1, m = 10, K = K_true, n = 10)
gaussprocess
samps <- gaussprocess(from = 0.1, to = 1, m = 10, K = K_true)
plot(data = samps, xt~t, type = 'l')
samps <- gaussprocess(from = 0.1, to = 1, m = 10, K = K_true)
plot(data = samps, xt~t, type = 'l')
samps <- gaussprocess(from = 0.1, to = 1, m = 10, K = K_true)
plot(data = samps, xt~t, type = 'l')
locations <- seq(0.1,10, by = 0.1)
locations
locations <- seq(0.1,10, by = 0.1)
K_true <- generate_K_true(sigma = 1, alpha = 1)
C_True <- compute_matrix_given_cov(from = 0.1, to = 10, m = 100, K = K_true)
samps <- gaussprocess(from = 0.1, to = 10, m = 100, K = K_true)
plot(data = samps, xt~t, type = 'l')
gaussprocess
Q <- joint_prec_construct(t_vec = locations, a = 1, sd = 1)
samps <- sim_sGP_Var(t = locations, a = 1, sd = 1)
samps
library(sGPfit)
samps <- sim_sGP_Var(t = locations, a = 1, sd = 1)
plot(data = samps, 'function'~t, type = 'l')
samps
samps <- sim_sGP_Var(t = locations, a = 1, sd = 1)
plot(data = samps, function~t, type = 'l')
samps <- sim_sGP_Var(t = locations, a = 1, sd = 1)
plot(samps[,2] ~ samps[,1], type = 'l')
plot(samps[,3] ~ samps[,1], type = 'l')
samps <- sim_sGP_Var(t = locations, a = 1, sd = 1)
plot(samps[,2] ~ samps[,1], type = 'l', ylab = "f", xlab = 't')
plot(samps[,3] ~ samps[,1], type = 'l', ylab = "f'", xlab = 't')
samps <- sampling_from_BT(x = locations, a = 1, k = 20, region = c(0,10), n = 1)
samps
samps <- sampling_from_BT(x = locations, a = 1, k = 20, region = c(0,10), n = 1)
plot(samps[,1]~locations, ylab = "f", xlab = "t")
samps <- sampling_from_BT(x = locations, a = 1, k = 20, region = c(0,10), n = 1)
plot(samps[,1]~locations, ylab = "f", xlab = "t", type = 'l')
devtools::check()
